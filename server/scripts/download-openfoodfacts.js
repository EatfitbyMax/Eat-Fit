const https = require('https');
const fs = require('fs');
const path = require('path');

const downloadWithRedirects = (url, maxRedirects = 5) => {
  return new Promise((resolve, reject) => {
    const download = (currentUrl, redirectCount = 0) => {
      if (redirectCount > maxRedirects) {
        reject(new Error(`Trop de redirections apr√®s ${maxRedirects} tentatives`));
        return;
      }

      const request = https.get(currentUrl, (response) => {
        const { statusCode, headers } = response;

        if (statusCode >= 300 && statusCode < 400 && headers.location) {
          console.log(`Redirection ${statusCode} vers: ${headers.location}`);
          download(headers.location, redirectCount + 1);
          return;
        }

        if (statusCode !== 200) {
          reject(new Error(`Status: ${statusCode}`));
          return;
        }

        const dataDir = path.join(__dirname, '../data');
        if (!fs.existsSync(dataDir)) {
          fs.mkdirSync(dataDir, { recursive: true });
        }

        const file = fs.createWriteStream(path.join(dataDir, 'openfoodfacts.json'));
        response.pipe(file);

        file.on('finish', () => {
          file.close();
          console.log('‚úÖ Base OpenFoodFacts t√©l√©charg√©e avec succ√®s');
          resolve();
        });

        file.on('error', (err) => {
          fs.unlink(path.join(dataDir, 'openfoodfacts.json'), () => {});
          reject(err);
        });
      });

      request.on('error', reject);
      request.setTimeout(30000, () => {
        request.destroy();
        reject(new Error('Timeout'));
      });
    };

    download(url);
  });
};

async function updateOpenFoodFacts() {
  try {
    console.log('[OpenFoodFacts] üîÑ T√©l√©chargement de la base OpenFoodFacts...');
    console.log('[OpenFoodFacts] üì• D√©but du t√©l√©chargement depuis OpenFoodFacts...');

    const url = 'https://static.openfoodfacts.org/data/en.openfoodfacts.org.products.json';
    const https = require('https');
const fs = require('fs');
const path = require('path');

const downloadWithRedirects = (url, maxRedirects = 5) => {
  return new Promise((resolve, reject) => {
    const request = https.get(url, (res) => {
      // G√©rer les redirections
      if (res.statusCode === 302 || res.statusCode === 301) {
        const redirectUrl = res.headers.location;
        console.log(`[OpenFoodFacts] üîÑ Redirection vers: ${redirectUrl}`);

        // Suivre la redirection
        const redirectedReq = https.get(redirectUrl, (redirectedRes) => {
          if (redirectedRes.statusCode !== 200) {
            reject(new Error(`Status after redirect: ${redirectedRes.statusCode}`));
            return;
          }

          const dataDir = path.join(__dirname, '../data');
            if (!fs.existsSync(dataDir)) {
                fs.mkdirSync(dataDir, { recursive: true });
            }

            const file = fs.createWriteStream(path.join(dataDir, 'openfoodfacts.json'));
            redirectedRes.pipe(file);

            file.on('finish', () => {
                file.close();
                console.log('‚úÖ Base OpenFoodFacts t√©l√©charg√©e avec succ√®s');
                resolve();
            });

            file.on('error', (err) => {
                fs.unlink(path.join(dataDir, 'openfoodfacts.json'), () => {});
                reject(err);
            });
        });

        redirectedReq.on('error', reject);
        return;
      }

      if (res.statusCode !== 200) {
        reject(new Error(`Status: ${res.statusCode}`));
        return;
      }

      const dataDir = path.join(__dirname, '../data');
        if (!fs.existsSync(dataDir)) {
            fs.mkdirSync(dataDir, { recursive: true });
        }

        const file = fs.createWriteStream(path.join(dataDir, 'openfoodfacts.json'));
        res.pipe(file);

        file.on('finish', () => {
            file.close();
            console.log('‚úÖ Base OpenFoodFacts t√©l√©charg√©e avec succ√®s');
            resolve();
        });

        file.on('error', (err) => {
            fs.unlink(path.join(dataDir, 'openfoodfacts.json'), () => {});
            reject(err);
        });
    });

    request.on('error', reject);
  });
};

async function updateOpenFoodFacts() {
  try {
    console.log('[OpenFoodFacts] üîÑ T√©l√©chargement de la base OpenFoodFacts...');
    console.log('[OpenFoodFacts] üì• D√©but du t√©l√©chargement depuis OpenFoodFacts...');

    const url = 'https://static.openfoodfacts.org/data/en.openfoodfacts.org.products.json';
    await downloadWithRedirects(url);

    console.log('[OpenFoodFacts] ‚úÖ Mise √† jour termin√©e avec succ√®s');
  } catch (error) {
    console.error('[OpenFoodFacts] ‚ùå Erreur t√©l√©chargement:', error);
    throw error;
  }
}

// Exporter pour utilisation dans le serveur
module.exports = { updateOpenFoodFacts };

// Ex√©cuter si appel√© directement
if (require.main === module) {
  updateOpenFoodFacts().catch(console.error);
}