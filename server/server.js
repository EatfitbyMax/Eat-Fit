// Charger les variables d'environnement en premier
require('dotenv').config();

const express = require('express');
const cors = require('cors');
const fs = require('fs').promises;
const path = require('path');

const app = express();
const PORT = process.env.PORT || 5000;
const DATA_DIR = path.join(__dirname, 'data');
const CLIENT_DIR = path.join(DATA_DIR, 'Client');
const COACH_DIR = path.join(DATA_DIR, 'Coach');
const STRAVA_DIR = path.join(DATA_DIR, 'Strava');

// Configuration Strava avec les variables d'environnement
const STRAVA_CLIENT_ID = process.env.EXPO_PUBLIC_STRAVA_CLIENT_ID || '159394';
const STRAVA_CLIENT_SECRET = process.env.EXPO_PUBLIC_STRAVA_CLIENT_SECRET || '0a888961cf64a2294908224b07b222ccba150700';

// Middleware de base
app.use(cors({
  origin: true,
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin']
}));

app.use(express.json({ limit: '50mb' }));

// Logging d√©taill√© pour diagnostiquer les probl√®mes de routes
app.use((req, res, next) => {
  const timestamp = new Date().toISOString();
  console.log(`üì° [${timestamp}] ${req.method} ${req.path}`);

  // Log sp√©cial pour les routes d'hydratation
  if (req.path.includes('/api/water/')) {
    console.log(`üíß [WATER_REQUEST] Route hydratation d√©tect√©e:`);
    console.log(`   - Method: ${req.method}`);
    console.log(`   - Path: ${req.path}`);
    console.log(`   - Params: ${JSON.stringify(req.params)}`);
    console.log(`   - Query: ${JSON.stringify(req.query)}`);
    if (req.method === 'POST') {
      console.log(`   - Body: ${JSON.stringify(req.body)}`);
    }
  }

  next();
});

// Cr√©er les dossiers s'ils n'existent pas
async function ensureDataDirs() {
  try {
    await fs.mkdir(DATA_DIR, { recursive: true });
    await fs.mkdir(CLIENT_DIR, { recursive: true });
    await fs.mkdir(COACH_DIR, { recursive: true });
    await fs.mkdir(STRAVA_DIR, { recursive: true });
    console.log('üìÅ R√©pertoires data/Client, data/Coach et data/Strava v√©rifi√©s');
  } catch (error) {
    console.error('Erreur cr√©ation r√©pertoires:', error);
  }
}

// Route de sant√© principale - optimis√©e pour les health checks
app.get('/', (req, res) => {
  res.status(200).json({ status: 'OK' });
});

// Route de sant√© d√©taill√©e
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'healthy',
    message: 'Serveur EatFitByMax op√©rationnel',
    timestamp: new Date().toISOString(),
    uptime: Math.floor(process.uptime())
  });
});

app.get('/api/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    message: 'Serveur EatFitByMax fonctionnel',
    timestamp: new Date().toISOString(),
    uptime: Math.floor(process.uptime())
  });
});

app.get('/api/health-check', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    message: 'Serveur VPS EatFitByMax op√©rationnel',
    timestamp: new Date().toISOString(),
    port: PORT
  });
});

// Fonction pour lire le fichier utilisateur dans la nouvelle structure (dossiers nom_pr√©nom)
async function readUserFile(userId, userType = 'client') {
  try {
    const userDir = userType === 'coach' ? COACH_DIR : CLIENT_DIR;

    // Rechercher dans la nouvelle structure (dossiers nom_pr√©nom)
    const folders = await fs.readdir(userDir);
    for (const folder of folders) {
      if (!folder.includes('_')) continue; // Ignorer les fichiers qui ne sont pas des dossiers nom_pr√©nom

      const profilPath = path.join(userDir, folder, 'Info', 'profil.json');
      try {
        const data = await fs.readFile(profilPath, 'utf8');
        const userData = JSON.parse(data);
        if (userData.id === userId) {
          console.log(`üìÅ Utilisateur trouv√© dans: ${folder}`);
          return userData;
        }
      } catch (e) {
        // Ignorer les erreurs de lecture de fichiers individuels
      }
    }

    return null; // Utilisateur non trouv√©
  } catch (error) {
    return null;
  }
}

// Fonction pour rechercher un utilisateur par ID dans la nouvelle structure
async function findUserById(userId) {
  console.log('üîç [SEARCH_USER] Recherche utilisateur ID:', userId);

  // Essayer client d'abord
  try {
    const userData = await readUserFile(userId, 'client');
    if (userData) {
      console.log('‚úÖ [SEARCH_USER] Trouv√© dans Client/');
      return { userData, userType: 'client' };
    }
  } catch (error) {
    console.log('‚ö†Ô∏è [SEARCH_USER] Erreur lecture Client/', error.message);
  }

  // Essayer coach ensuite
  try {
    const userData = await readUserFile(userId, 'coach');
    if (userData) {
      console.log('‚úÖ [SEARCH_USER] Trouv√© dans Coach/');
      return { userData, userType: 'coach' };
    }
  } catch (error) {
    console.log('‚ö†Ô∏è [SEARCH_USER] Erreur lecture Coach/', error.message);
  }

  console.log('‚ùå [SEARCH_USER] Utilisateur non trouv√©');
  return null;
}

// Fonction pour cr√©er la structure de dossiers d'un utilisateur
async function createUserDirectoryStructure(userId, userData, userType = 'client') {
  try {
    const userDir = userType === 'coach' ? COACH_DIR : CLIENT_DIR;

    // Cr√©er le nom du dossier : nom_pr√©nom
    const folderName = `${userData.lastName || 'inconnu'}_${userData.firstName || 'inconnu'}`.replace(/[^a-zA-Z0-9_-]/g, '');
    const userFolderPath = path.join(userDir, folderName);

    console.log(`üìÅ Cr√©ation structure dossiers pour: ${folderName}`);

    // Cr√©er tous les dossiers n√©cessaires
    const foldersToCreate = [
      userFolderPath,
      path.join(userFolderPath, 'Info'),
      path.join(userFolderPath, 'Strava'),
      path.join(userFolderPath, 'Health'),
      path.join(userFolderPath, 'Nutrition'),
      path.join(userFolderPath, 'Entrainements'),
      path.join(userFolderPath, 'Progr√®s'),
      path.join(userFolderPath, 'Forme')
    ];

    for (const folder of foldersToCreate) {
      await fs.mkdir(folder, { recursive: true });
    }

    // Cr√©er les fichiers initiaux avec donn√©es par d√©faut
    const initialFiles = [
      // Info/
      {
        path: path.join(userFolderPath, 'Info', 'profil.json'),
        data: userData
      },
      {
        path: path.join(userFolderPath, 'Info', 'preferences-app.json'),
        data: {
          theme: 'system',
          language: 'fr',
          units: 'metric',
          notifications: true
        }
      },
      {
        path: path.join(userFolderPath, 'Info', 'integrations.json'),
        data: {
          appleHealth: { connected: false, permissions: [], lastSync: null },
          strava: { connected: false, lastSync: null, athleteId: null }
        }
      },
      {
        path: path.join(userFolderPath, 'Info', 'messages.json'),
        data: []
      },
      {
        path: path.join(userFolderPath, 'Info', 'notifications.json'),
        data: {
          pushNotifications: true,
          mealReminders: true,
          workoutReminders: true,
          progressUpdates: true,
          coachMessages: true,
          weeklyReports: true,
          soundEnabled: true,
          vibrationEnabled: true
        }
      },
      {
        path: path.join(userFolderPath, 'Info', 'notification-times.json'),
        data: {
          breakfast: { hour: 8, minute: 0 },
          lunch: { hour: 12, minute: 30 },
          dinner: { hour: 19, minute: 0 },
          workout: { hour: 18, minute: 0 }
        }
      },
      // Strava/
      {
        path: path.join(userFolderPath, 'Strava', 'compte.json'),
        data: { connected: false }
      },
      {
        path: path.join(userFolderPath, 'Strava', 'activites.json'),
        data: []
      },
      // Health/
      {
        path: path.join(userFolderPath, 'Health', 'health.json'),
        data: []
      },
      // Nutrition/
      {
        path: path.join(userFolderPath, 'Nutrition', 'aliments.json'),
        data: []
      },
      // Entrainements/
      {
        path: path.join(userFolderPath, 'Entrainements', 'entrainements.json'),
        data: []
      },
      // Progr√®s/
      {
        path: path.join(userFolderPath, 'Progr√®s', 'poids.json'),
        data: {
          startWeight: userData.weight || 0,
          currentWeight: userData.weight || 0,
          targetWeight: 0,
          lastWeightUpdate: null,
          targetAsked: false,
          weightHistory: []
        }
      },
      {
        path: path.join(userFolderPath, 'Progr√®s', 'mensurations.json'),
        data: {}
      },
      // Forme/
      {
        path: path.join(userFolderPath, 'Forme', 'sommeil-fatigue.json'),
        data: { globalData: {} }
      }
    ];

    // √âcrire tous les fichiers initiaux
    for (const file of initialFiles) {
      await fs.writeFile(file.path, JSON.stringify(file.data, null, 2));
    }

    console.log(`‚úÖ Structure cr√©√©e avec succ√®s: ${folderName}`);
    return { folderName, userFolderPath };
  } catch (error) {
    console.error(`‚ùå Erreur cr√©ation structure utilisateur ${userId}:`, error);
    throw error;
  }
}

// Fonction pour √©crire le fichier utilisateur (mise √† jour)
async function writeUserFile(userId, userData, userType = 'client') {
  try {
    const userDir = userType === 'coach' ? COACH_DIR : CLIENT_DIR;
    const folderName = `${userData.lastName || 'inconnu'}_${userData.firstName || 'inconnu'}`.replace(/[^a-zA-Z0-9_-]/g, '');
    const userFolderPath = path.join(userDir, folderName);
    const profilPath = path.join(userFolderPath, 'Info', 'profil.json');

    // Mettre √† jour le profil dans la structure
    await fs.writeFile(profilPath, JSON.stringify(userData, null, 2));
    console.log(`üìÅ Profil mis √† jour dans la structure: ${folderName}`);
    return true;
  } catch (error) {
    console.error(`Erreur √©criture utilisateur ${userId}:`, error);
    throw error;
  }
}

// Fonction pour lister tous les utilisateurs d'un type
async function getAllUsers(userType = 'client') {
  try {
    const userDir = userType === 'coach' ? COACH_DIR : CLIENT_DIR;
    const folders = await fs.readdir(userDir);
    const users = [];

    for (const folder of folders) {
      if (folder.includes('_')) { // Dossiers nom_pr√©nom
        const profilPath = path.join(userDir, folder, 'Info', 'profil.json');
        try {
          const data = await fs.readFile(profilPath, 'utf8');
          const userData = JSON.parse(data);
          users.push(userData);
        } catch (e) {
          // Ignorer les erreurs de lecture
        }
      }
    }

    return users;
  } catch (error) {
    console.error(`Erreur lecture utilisateurs ${userType}:`, error);
    return [];
  }
}

// Routes pour les utilisateurs (clients)
app.get('/api/users', async (req, res) => {
  try {
    const clients = await getAllUsers('client');
    console.log(`üìä R√©cup√©ration clients: ${clients.length} clients trouv√©s`);
    res.json(clients);
  } catch (error) {
    console.error('Erreur lecture clients:', error);
    res.json([]);
  }
});

app.post('/api/users', async (req, res) => {
  try {
    const clients = Array.isArray(req.body) ? req.body : [req.body];

    for (const client of clients) {
      if (client.id && (client.userType === 'client' || !client.userType)) {
        // Cr√©er la structure de dossiers lors de la cr√©ation
        await createUserDirectoryStructure(client.id, client, 'client');
      }
    }

    console.log('üíæ Sauvegarde clients:', clients.length);
    res.json({ success: true });
  } catch (error) {
    console.error('Erreur sauvegarde clients:', error);
    res.status(500).json({ error: 'Erreur sauvegarde clients' });
  }
});

// Routes pour les coaches
app.get('/api/coaches', async (req, res) => {
  try {
    const coaches = await getAllUsers('coach');
    console.log(`üë®‚Äçüíº R√©cup√©ration coaches: ${coaches.length} coaches trouv√©s`);
    res.json(coaches);
  } catch (error) {
    console.error('Erreur lecture coaches:', error);
    res.json([]);
  }
});

app.post('/api/coaches', async (req, res) => {
  try {
    const coaches = Array.isArray(req.body) ? req.body : [req.body];

    for (const coach of coaches) {
      if (coach.id) {
        // Cr√©er la structure de dossiers lors de la cr√©ation
        await createUserDirectoryStructure(coach.id, coach, 'coach');
      }
    }

    console.log('üíæ Sauvegarde coaches:', coaches.length);
    res.json({ success: true });
  } catch (error) {
    console.error('Erreur sauvegarde coaches:', error);
    res.status(500).json({ error: 'Erreur sauvegarde coaches' });
  }
});

// Route universelle pour r√©cup√©rer les donn√©es d'un utilisateur
app.get('/api/user-data/:userId', async (req, res) => {
  try {
    const { userId } = req.params;

    const userResult = await findUserById(userId);

    if (!userResult) {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }

    const { userData, userType } = userResult;
    console.log(`üìä Donn√©es utilisateur r√©cup√©r√©es: ${userId} (${userType})`);
    res.json(userData);
  } catch (error) {
    console.error(`Erreur r√©cup√©ration utilisateur ${req.params.userId}:`, error);
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// Route universelle pour sauvegarder les donn√©es d'un utilisateur
app.post('/api/user-data/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const userData = req.body;

    // D√©terminer le type d'utilisateur
    const userType = userData.userType === 'coach' ? 'coach' : 'client';

    // S'assurer que l'ID correspond
    userData.id = userId;
    userData.lastUpdated = new Date().toISOString();

    await writeUserFile(userId, userData, userType);

    console.log(`üíæ Donn√©es utilisateur sauvegard√©es: ${userId} (${userType})`);
    res.json({ success: true });
  } catch (error) {
    console.error(`Erreur sauvegarde utilisateur ${userId}:`, error);
    res.status(500).json({ error: 'Erreur sauvegarde donn√©es utilisateur' });
  }
});

// Route pour cr√©er la structure de dossiers d'un utilisateur
app.post('/api/create-user-structure', async (req, res) => {
  try {
    const { userId, userData, userType } = req.body;

    if (!userId || !userData) {
      return res.status(400).json({ error: 'userId et userData requis' });
    }

    const result = await createUserDirectoryStructure(userId, userData, userType || 'client');

    console.log(`‚úÖ Structure cr√©√©e via API pour: ${result.folderName}`);
    res.json({ 
      success: true, 
      folderName: result.folderName, 
      message: 'Structure de dossiers cr√©√©e avec succ√®s' 
    });

  } catch (error) {
    console.error('‚ùå Erreur cr√©ation structure via API:', error);
    res.status(500).json({ error: 'Erreur cr√©ation structure utilisateur' });
  }
});

// D√©marrage du serveur
async function startServer() {
  try {
    await ensureDataDirs();

    const server = app.listen(PORT, '0.0.0.0', () => {
      console.log(`üöÄ Serveur EatFitByMax d√©marr√© sur le port ${PORT}`);
      console.log(`üåê API disponible sur: https://eatfitbymax.cloud`);
      console.log(`‚úÖ Nouvelle structure: {nom_pr√©nom} avec dossiers organis√©s`);
    });

    server.on('error', (error) => {
      console.error('‚ùå Erreur serveur:', error);
      process.exit(1);
    });

  } catch (error) {
    console.error('Erreur d√©marrage serveur:', error);
    process.exit(1);
  }
}

// Gestion des erreurs globales
app.use((err, req, res, next) => {
  console.error('Erreur serveur:', err);
  res.status(500).json({ error: 'Erreur interne du serveur' });
});

startServer();